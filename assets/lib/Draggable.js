(function webpackUniversalModuleDefinition(root, factory) {
    if(typeof exports === 'object' && typeof module === 'object')
        module.exports = factory(require("react"), require("react-dom"));
    else if(typeof define === 'function' && define.amd)
        define(["react", "react-dom"], factory);
    else if(typeof exports === 'object')
        exports["ReactDraggable"] = factory(require("react"), require("react-dom"));
    else
        root["ReactDraggable"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
    return /******/ (function(modules) { // webpackBootstrap
        /******/ 	// The module cache
        /******/ 	var installedModules = {};
        /******/
        /******/ 	// The require function
        /******/ 	function __webpack_require__(moduleId) {
            /******/
            /******/ 		// Check if module is in cache
            /******/ 		if(installedModules[moduleId])
            /******/ 			return installedModules[moduleId].exports;
            /******/
            /******/ 		// Create a new module (and put it into the cache)
            /******/ 		var module = installedModules[moduleId] = {
                /******/ 			exports: {},
                /******/ 			id: moduleId,
                /******/ 			loaded: false
                /******/ 		};
            /******/
            /******/ 		// Execute the module function
            /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            /******/ 		// Flag the module as loaded
            /******/ 		module.loaded = true;
            /******/
            /******/ 		// Return the exports of the module
            /******/ 		return module.exports;
            /******/ 	}
        /******/
        /******/
        /******/ 	// expose the modules object (__webpack_modules__)
        /******/ 	__webpack_require__.m = modules;
        /******/
        /******/ 	// expose the module cache
        /******/ 	__webpack_require__.c = installedModules;
        /******/
        /******/ 	// __webpack_public_path__
        /******/ 	__webpack_require__.p = "";
        /******/
        /******/ 	// Load entry module and return exports
        /******/ 	return __webpack_require__(0);
        /******/ })
    /************************************************************************/
    /******/ ([
        /* 0 */
        /***/ function(module, exports, __webpack_require__) {

            'use strict';

            module.exports = __webpack_require__(1).default;
            module.exports.DraggableCore = __webpack_require__(9).default;

            /***/ },
        /* 1 */
        /***/ function(module, exports, __webpack_require__) {

            'use strict';

            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _react = __webpack_require__(2);

            var _react2 = _interopRequireDefault(_react);

            var _reactDom = __webpack_require__(3);

            var _reactDom2 = _interopRequireDefault(_reactDom);

            var _classnames = __webpack_require__(4);

            var _classnames2 = _interopRequireDefault(_classnames);

            var _domFns = __webpack_require__(5);

            var _positionFns = __webpack_require__(8);

            var _shims = __webpack_require__(6);

            var _DraggableCore = __webpack_require__(9);

            var _DraggableCore2 = _interopRequireDefault(_DraggableCore);

            var _log = __webpack_require__(11);

            var _log2 = _interopRequireDefault(_log);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            // $FlowIgnore


            /*:: import type {DraggableEventHandler} from './utils/types';*/
            /*:: type DraggableState = {
             dragging: boolean,
             dragged: boolean,
             x: number, y: number,
             slackX: number, slackY: number,
             isElementSVG: boolean
             };*/


            //
            // Define <Draggable>
            //

            /*:: type ConstructorProps = {
             position: { x: number, y: number },
             defaultPosition: { x: number, y: number }
             };*/

            var Draggable = function (_React$Component) {
                _inherits(Draggable, _React$Component);

                function Draggable(props /*: ConstructorProps*/) {
                    _classCallCheck(this, Draggable);

                    var _this = _possibleConstructorReturn(this, (Draggable.__proto__ || Object.getPrototypeOf(Draggable)).call(this, props));

                    _this.onDragStart = function (e, coreData) {
                        (0, _log2.default)('Draggable: onDragStart: %j', coreData);

                        // Short-circuit if user's callback killed it.
                        var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_this, coreData));
                        // Kills start event on core as well, so move handlers are never bound.
                        if (shouldStart === false) return false;

                        _this.setState({ dragging: true, dragged: true });
                    };

                    _this.onDrag = function (e, coreData) {
                        if (!_this.state.dragging) return false;
                        (0, _log2.default)('Draggable: onDrag: %j', coreData);

                        var uiData = (0, _positionFns.createDraggableData)(_this, coreData);

                        var newState /*: $Shape<DraggableState>*/ = {
                            x: uiData.x,
                            y: uiData.y
                        };

                        // Keep within bounds.
                        if (_this.props.bounds) {
                            // Save original x and y.
                            var _x = newState.x,
                                _y = newState.y;

                            // Add slack to the values used to calculate bound position. This will ensure that if
                            // we start removing slack, the element won't react to it right away until it's been
                            // completely removed.

                            newState.x += _this.state.slackX;
                            newState.y += _this.state.slackY;

                            // Get bound position. This will ceil/floor the x and y within the boundaries.
                            // $FlowBug

                            // Recalculate slack by noting how much was shaved by the boundPosition handler.
                            var _getBoundPosition = (0, _positionFns.getBoundPosition)(_this, newState.x, newState.y);

                            var _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2);

                            newState.x = _getBoundPosition2[0];
                            newState.y = _getBoundPosition2[1];
                            newState.slackX = _this.state.slackX + (_x - newState.x);
                            newState.slackY = _this.state.slackY + (_y - newState.y);

                            // Update the event we fire to reflect what really happened after bounds took effect.
                            uiData.x = _x;
                            uiData.y = _y;
                            uiData.deltaX = newState.x - _this.state.x;
                            uiData.deltaY = newState.y - _this.state.y;
                        }

                        // Short-circuit if user's callback killed it.
                        var shouldUpdate = _this.props.onDrag(e, uiData);
                        if (shouldUpdate === false) return false;

                        _this.setState(newState);
                    };

                    _this.onDragStop = function (e, coreData) {
                        if (!_this.state.dragging) return false;

                        // Short-circuit if user's callback killed it.
                        var shouldStop = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_this, coreData));
                        if (shouldStop === false) return false;

                        (0, _log2.default)('Draggable: onDragStop: %j', coreData);

                        var newState /*: $Shape<DraggableState>*/ = {
                            dragging: false,
                            slackX: 0,
                            slackY: 0
                        };

                        // If this is a controlled component, the result of this operation will be to
                        // revert back to the old position. We expect a handler on `onDragStop`, at the least.
                        var controlled = Boolean(_this.props.position);
                        if (controlled) {
                            var _this$props$position = _this.props.position,
                                _x2 = _this$props$position.x,
                                _y2 = _this$props$position.y;

                            newState.x = _x2;
                            newState.y = _y2;
                        }

                        _this.setState(newState);
                    };

                    _this.state = {
                        // Whether or not we are currently dragging.
                        dragging: false,

                        // Whether or not we have been dragged before.
                        dragged: false,

                        // Current transform x and y.
                        x: props.position ? props.position.x : props.defaultPosition.x,
                        y: props.position ? props.position.y : props.defaultPosition.y,

                        // Used for compensating for out-of-bounds drags
                        slackX: 0, slackY: 0,

                        // Can only determine if SVG after mounting
                        isElementSVG: false
                    };
                    return _this;
                }

                _createClass(Draggable, [{
                    key: 'componentWillMount',
                    value: function componentWillMount() {
                        if (this.props.position && !(this.props.onDrag || this.props.onStop)) {
                            // eslint-disable-next-line
                            console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
                        }
                    }
                }, {
                    key: 'componentDidMount',
                    value: function componentDidMount() {
                        // Check to see if the element passed is an instanceof SVGElement
                        if (typeof SVGElement !== 'undefined' && _reactDom2.default.findDOMNode(this) instanceof SVGElement) {
                            this.setState({ isElementSVG: true });
                        }
                    }
                }, {
                    key: 'componentWillReceiveProps',
                    value: function componentWillReceiveProps(nextProps /*: Object*/) {
                        // Set x/y if position has changed
                        if (nextProps.position && (!this.props.position || nextProps.position.x !== this.props.position.x || nextProps.position.y !== this.props.position.y)) {
                            this.setState({ x: nextProps.position.x, y: nextProps.position.y });
                        }
                    }
                }, {
                    key: 'componentWillUnmount',
                    value: function componentWillUnmount() {
                        this.setState({ dragging: false }); // prevents invariant if unmounted while dragging
                    }
                }, {
                    key: 'render',
                    value: function render() /*: React.Element<any>*/ {
                        var _classNames;

                        var style = {},
                            svgTransform = null;

                        // If this is controlled, we don't want to move it - unless it's dragging.
                        var controlled = Boolean(this.props.position);
                        var draggable = !controlled || this.state.dragging;

                        var position = this.props.position || this.props.defaultPosition;
                        var transformOpts = {
                            // Set left if horizontal drag is enabled
                            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : position.x,

                            // Set top if vertical drag is enabled
                            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : position.y
                        };

                        // If this element was SVG, we use the `transform` attribute.
                        if (this.state.isElementSVG) {
                            svgTransform = (0, _domFns.createSVGTransform)(transformOpts);
                        } else {
                            // Add a CSS transform to move the element around. This allows us to move the element around
                            // without worrying about whether or not it is relatively or absolutely positioned.
                            // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
                            // has a clean slate.
                            style = (0, _domFns.createCSSTransform)(transformOpts);
                        }

                        var _props = this.props,
                            defaultClassName = _props.defaultClassName,
                            defaultClassNameDragging = _props.defaultClassNameDragging,
                            defaultClassNameDragged = _props.defaultClassNameDragged;

                        // Mark with class while dragging

                        var className = (0, _classnames2.default)(this.props.children.props.className || '', defaultClassName, (_classNames = {}, _defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), _defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));

                        // Reuse the child provided
                        // This makes it flexible to use whatever element is wanted (div, ul, etc)
                        return _react2.default.createElement(
                            _DraggableCore2.default,
                            _extends({}, this.props, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }),
                            _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
                                className: className,
                                style: _extends({}, this.props.children.props.style, style),
                                transform: svgTransform
                            })
                        );
                    }
                }]);

                return Draggable;
            }(_react2.default.Component);

            Draggable.displayName = 'Draggable';
            Draggable.propTypes = _extends({}, _DraggableCore2.default.propTypes, {

                /**
                 * `axis` determines which axis the draggable can move.
                 *
                 *  Note that all callbacks will still return data as normal. This only
                 *  controls flushing to the DOM.
                 *
                 * 'both' allows movement horizontally and vertically.
                 * 'x' limits movement to horizontal axis.
                 * 'y' limits movement to vertical axis.
                 * 'none' limits all movement.
                 *
                 * Defaults to 'both'.
                 */
                axis: _react.PropTypes.oneOf(['both', 'x', 'y', 'none']),

                /**
                 * `bounds` determines the range of movement available to the element.
                 * Available values are:
                 *
                 * 'parent' restricts movement within the Draggable's parent node.
                 *
                 * Alternatively, pass an object with the following properties, all of which are optional:
                 *
                 * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
                 *
                 * All values are in px.
                 *
                 * Example:
                 *
                 * ```jsx
                 *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable bounds={{right: 300, bottom: 300}}>
	   *              <div>Content</div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
                 * ```
                 */
                bounds: _react.PropTypes.oneOfType([_react.PropTypes.shape({
                    left: _react.PropTypes.number,
                    right: _react.PropTypes.number,
                    top: _react.PropTypes.number,
                    bottom: _react.PropTypes.number
                }), _react.PropTypes.string, _react.PropTypes.oneOf([false])]),

                defaultClassName: _react.PropTypes.string,
                defaultClassNameDragging: _react.PropTypes.string,
                defaultClassNameDragged: _react.PropTypes.string,

                /**
                 * `defaultPosition` specifies the x and y that the dragged item should start at
                 *
                 * Example:
                 *
                 * ```jsx
                 *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
                 * ```
                 */
                defaultPosition: _react.PropTypes.shape({
                    x: _react.PropTypes.number,
                    y: _react.PropTypes.number
                }),

                /**
                 * `position`, if present, defines the current position of the element.
                 *
                 *  This is similar to how form elements in React work - if no `position` is supplied, the component
                 *  is uncontrolled.
                 *
                 * Example:
                 *
                 * ```jsx
                 *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable position={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
                 * ```
                 */
                position: _react.PropTypes.shape({
                    x: _react.PropTypes.number,
                    y: _react.PropTypes.number
                }),

                /**
                 * These properties should be defined on the child, not here.
                 */
                className: _shims.dontSetMe,
                style: _shims.dontSetMe,
                transform: _shims.dontSetMe
            });
            Draggable.defaultProps = _extends({}, _DraggableCore2.default.defaultProps, {
                axis: 'both',
                bounds: false,
                defaultClassName: 'react-draggable',
                defaultClassNameDragging: 'react-draggable-dragging',
                defaultClassNameDragged: 'react-draggable-dragged',
                defaultPosition: { x: 0, y: 0 },
                position: null
            });
            exports.default = Draggable;

            /***/ },
        /* 2 */
        /***/ function(module, exports) {

            module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

            /***/ },
        /* 3 */
        /***/ function(module, exports) {

            module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

            /***/ },
        /* 4 */
        /***/ function(module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
             Copyright (c) 2016 Jed Watson.
             Licensed under the MIT License (MIT), see
             http://jedwatson.github.io/classnames
             */
            /* global define */

            (function () {
                'use strict';

                var hasOwn = {}.hasOwnProperty;

                function classNames () {
                    var classes = [];

                    for (var i = 0; i < arguments.length; i++) {
                        var arg = arguments[i];
                        if (!arg) continue;

                        var argType = typeof arg;

                        if (argType === 'string' || argType === 'number') {
                            classes.push(arg);
                        } else if (Array.isArray(arg)) {
                            classes.push(classNames.apply(null, arg));
                        } else if (argType === 'object') {
                            for (var key in arg) {
                                if (hasOwn.call(arg, key) && arg[key]) {
                                    classes.push(key);
                                }
                            }
                        }
                    }

                    return classes.join(' ');
                }

                if (typeof module !== 'undefined' && module.exports) {
                    module.exports = classNames;
                } else if (true) {
                    // register as 'classnames', consistent with npm package name
                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
                        return classNames;
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {
                    window.classNames = classNames;
                }
            }());


            /***/ },
        /* 5 */
        /***/ function(module, exports, __webpack_require__) {

            'use strict';

            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            exports.matchesSelector = matchesSelector;
            exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
            exports.addEvent = addEvent;
            exports.removeEvent = removeEvent;
            exports.outerHeight = outerHeight;
            exports.outerWidth = outerWidth;
            exports.innerHeight = innerHeight;
            exports.innerWidth = innerWidth;
            exports.offsetXYFromParent = offsetXYFromParent;
            exports.createCSSTransform = createCSSTransform;
            exports.createSVGTransform = createSVGTransform;
            exports.getTouch = getTouch;
            exports.getTouchIdentifier = getTouchIdentifier;
            exports.addUserSelectStyles = addUserSelectStyles;
            exports.removeUserSelectStyles = removeUserSelectStyles;
            exports.styleHacks = styleHacks;

            var _shims = __webpack_require__(6);

            var _getPrefix = __webpack_require__(7);

            var _getPrefix2 = _interopRequireDefault(_getPrefix);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

            /*:: import type {ControlPosition} from './types';*/


            var matchesSelectorFunc = '';
            function matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/ {
                if (!matchesSelectorFunc) {
                    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
                        // $FlowIgnore: Doesn't think elements are indexable
                        return (0, _shims.isFunction)(el[method]);
                    });
                }

                // $FlowIgnore: Doesn't think elements are indexable
                return el[matchesSelectorFunc].call(el, selector);
            }

            // Works up the tree to the draggable itself attempting to match selector.
            function matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/ {
                var node = el;
                do {
                    if (matchesSelector(node, selector)) return true;
                    if (node === baseNode) return false;
                    node = node.parentNode;
                } while (node);

                return false;
            }

            function addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
                if (!el) {
                    return;
                }
                if (el.attachEvent) {
                    el.attachEvent('on' + event, handler);
                } else if (el.addEventListener) {
                    el.addEventListener(event, handler, true);
                } else {
                    // $FlowIgnore: Doesn't think elements are indexable
                    el['on' + event] = handler;
                }
            }

            function removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
                if (!el) {
                    return;
                }
                if (el.detachEvent) {
                    el.detachEvent('on' + event, handler);
                } else if (el.removeEventListener) {
                    el.removeEventListener(event, handler, true);
                } else {
                    // $FlowIgnore: Doesn't think elements are indexable
                    el['on' + event] = null;
                }
            }

            function outerHeight(node /*: HTMLElement*/) /*: number*/ {
                // This is deliberately excluding margin for our calculations, since we are using
                // offsetTop which is including margin. See getBoundPosition
                var height = node.clientHeight;
                var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
                height += (0, _shims.int)(computedStyle.borderTopWidth);
                height += (0, _shims.int)(computedStyle.borderBottomWidth);
                return height;
            }

            function outerWidth(node /*: HTMLElement*/) /*: number*/ {
                // This is deliberately excluding margin for our calculations, since we are using
                // offsetLeft which is including margin. See getBoundPosition
                var width = node.clientWidth;
                var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
                width += (0, _shims.int)(computedStyle.borderLeftWidth);
                width += (0, _shims.int)(computedStyle.borderRightWidth);
                return width;
            }
            function innerHeight(node /*: HTMLElement*/) /*: number*/ {
                var height = node.clientHeight;
                var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
                height -= (0, _shims.int)(computedStyle.paddingTop);
                height -= (0, _shims.int)(computedStyle.paddingBottom);
                return height;
            }

            function innerWidth(node /*: HTMLElement*/) /*: number*/ {
                var width = node.clientWidth;
                var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
                width -= (0, _shims.int)(computedStyle.paddingLeft);
                width -= (0, _shims.int)(computedStyle.paddingRight);
                return width;
            }

            // Get from offsetParent
            function offsetXYFromParent(evt /*: {clientX: number, clientY: number}*/, offsetParent /*: HTMLElement*/) /*: ControlPosition*/ {
                var isBody = offsetParent === offsetParent.ownerDocument.body;
                var offsetParentRect = isBody ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();

                var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
                var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;

                return { x: x, y: y };
            }

            function createCSSTransform(_ref) /*: Object*/ {
                var x = _ref.x,
                    y = _ref.y;

                // Replace unitless items with px
                return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix2.default), 'translate(' + x + 'px,' + y + 'px)');
            }

            function createSVGTransform(_ref3) /*: string*/ {
                var x = _ref3.x,
                    y = _ref3.y;

                return 'translate(' + x + ',' + y + ')';
            }

            function getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/ {
                return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function (t) {
                        return identifier === t.identifier;
                    }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function (t) {
                        return identifier === t.identifier;
                    });
            }

            function getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/ {
                if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
                if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
            }

            // User-select Hacks:
            //
            // Useful for preventing blue highlights all over everything when dragging.
            var userSelectPrefix = (0, _getPrefix.getPrefix)('user-select');
            var userSelect = (0, _getPrefix.browserPrefixToStyle)('user-select', userSelectPrefix);
            var userSelectStyle = ';' + userSelect + ': none;';
            var userSelectReplaceRegExp = new RegExp(';?' + userSelect + ': none;'); // leading ; not present on IE

            // Note we're passing `document` b/c we could be iframed
            function addUserSelectStyles(body /*: HTMLElement*/) {
                var style = body.getAttribute('style') || '';
                body.setAttribute('style', style + userSelectStyle);
            }

            function removeUserSelectStyles(body /*: HTMLElement*/) {
                var style = body.getAttribute('style') || '';
                body.setAttribute('style', style.replace(userSelectReplaceRegExp, ''));
            }

            function styleHacks() /*: Object*/ {
                var childStyle /*: Object*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                // Workaround IE pointer events; see #51
                // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
                return _extends({
                    touchAction: 'none'
                }, childStyle);
            }

            /***/ },
        /* 6 */
        /***/ function(module, exports) {

            'use strict';

            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.findInArray = findInArray;
            exports.isFunction = isFunction;
            exports.isNum = isNum;
            exports.int = int;
            exports.dontSetMe = dontSetMe;

            // @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
            function findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/ {
                for (var i = 0, length = array.length; i < length; i++) {
                    if (callback.apply(callback, [array[i], i, array])) return array[i];
                }
            }

            function isFunction(func /*: any*/) /*: boolean*/ {
                return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
            }

            function isNum(num /*: any*/) /*: boolean*/ {
                return typeof num === 'number' && !isNaN(num);
            }

            function int(a /*: string*/) /*: number*/ {
                return parseInt(a, 10);
            }

            function dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) {
                if (props[propName]) {
                    return new Error('Invalid prop ' + propName + ' passed to ' + componentName + ' - do not set this, set it on the child.');
                }
            }

            /***/ },
        /* 7 */
        /***/ function(module, exports) {

            'use strict';

            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.getPrefix = getPrefix;
            exports.browserPrefixToKey = browserPrefixToKey;
            exports.browserPrefixToStyle = browserPrefixToStyle;
            var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
            function getPrefix() /*: string*/ {
                var prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';

                // Checking specifically for 'window.document' is for pseudo-browser server-side
                // environments that define 'window' as the global context.
                // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)
                if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';

                var style = window.document.documentElement.style;

                if (prop in style) return '';

                for (var i = 0; i < prefixes.length; i++) {
                    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
                }

                return '';
            }

            function browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/ {
                return prefix ? '' + prefix + kebabToTitleCase(prop) : prop;
            }

            function browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/ {
                return prefix ? '-' + prefix.toLowerCase() + '-' + prop : prop;
            }

            function kebabToTitleCase(str /*: string*/) /*: string*/ {
                var out = '';
                var shouldCapitalize = true;
                for (var i = 0; i < str.length; i++) {
                    if (shouldCapitalize) {
                        out += str[i].toUpperCase();
                        shouldCapitalize = false;
                    } else if (str[i] === '-') {
                        shouldCapitalize = true;
                    } else {
                        out += str[i];
                    }
                }
                return out;
            }

            // Default export is the prefix itself, like 'Moz', 'Webkit', etc
            // Note that you may have to re-test for certain things; for instance, Chrome 50
            // can handle unprefixed `transform`, but not unprefixed `user-select`
            exports.default = getPrefix();

            /***/ },
        /* 8 */
        /***/ function(module, exports, __webpack_require__) {

            'use strict';

            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.getBoundPosition = getBoundPosition;
            exports.snapToGrid = snapToGrid;
            exports.canDragX = canDragX;
            exports.canDragY = canDragY;
            exports.getControlPosition = getControlPosition;
            exports.createCoreData = createCoreData;
            exports.createDraggableData = createDraggableData;

            var _shims = __webpack_require__(6);

            var _reactDom = __webpack_require__(3);

            var _reactDom2 = _interopRequireDefault(_reactDom);

            var _domFns = __webpack_require__(5);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            /*:: import type Draggable from '../Draggable';*/
            /*:: import type {Bounds, ControlPosition, DraggableData} from './types';*/
            /*:: import type DraggableCore from '../DraggableCore';*/
            function getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/ {
                // If no bounds, short-circuit and move on
                if (!draggable.props.bounds) return [x, y];

                // Clone new bounds
                var bounds = draggable.props.bounds;

                bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
                var node = _reactDom2.default.findDOMNode(draggable);

                if (typeof bounds === 'string') {
                    var ownerDocument = node.ownerDocument;

                    var ownerWindow = ownerDocument.defaultView;
                    var boundNode = void 0;
                    if (bounds === 'parent') {
                        boundNode = node.parentNode;
                    } else {
                        boundNode = ownerDocument.querySelector(bounds);
                        if (!boundNode) throw new Error('Bounds selector "' + bounds + '" could not find an element.');
                    }
                    var nodeStyle = ownerWindow.getComputedStyle(node);
                    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
                    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
                    bounds = {
                        left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.borderLeftWidth) + (0, _shims.int)(nodeStyle.marginLeft),
                        top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.borderTopWidth) + (0, _shims.int)(nodeStyle.marginTop),
                        right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft,
                        bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop
                    };
                }

                // Keep x and y below right and bottom limits...
                if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
                if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);

                // But above left and top limits.
                if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
                if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);

                return [x, y];
            }

            function snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/ {
                var x = Math.round(pendingX / grid[0]) * grid[0];
                var y = Math.round(pendingY / grid[1]) * grid[1];
                return [x, y];
            }

            function canDragX(draggable /*: Draggable*/) /*: boolean*/ {
                return draggable.props.axis === 'both' || draggable.props.axis === 'x';
            }

            function canDragY(draggable /*: Draggable*/) /*: boolean*/ {
                return draggable.props.axis === 'both' || draggable.props.axis === 'y';
            }

            // Get {x, y} positions from event.
            function getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/ {
                var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
                if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
                var node = _reactDom2.default.findDOMNode(draggableCore);
                // User can provide an offsetParent if desired.
                var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
                return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent);
            }

            // Create an data object exposed by <DraggableCore>'s events
            function createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/ {
                var state = draggable.state;
                var isStart = !(0, _shims.isNum)(state.lastX);

                if (isStart) {
                    // If this is our first move, use the x and y as last coords.
                    return {
                        node: _reactDom2.default.findDOMNode(draggable),
                        deltaX: 0, deltaY: 0,
                        lastX: x, lastY: y,
                        x: x, y: y
                    };
                } else {
                    // Otherwise calculate proper values.
                    return {
                        node: _reactDom2.default.findDOMNode(draggable),
                        deltaX: x - state.lastX, deltaY: y - state.lastY,
                        lastX: state.lastX, lastY: state.lastY,
                        x: x, y: y
                    };
                }
            }

            // Create an data exposed by <Draggable>'s events
            function createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/ {
                return {
                    node: coreData.node,
                    x: draggable.state.x + coreData.deltaX,
                    y: draggable.state.y + coreData.deltaY,
                    deltaX: coreData.deltaX,
                    deltaY: coreData.deltaY,
                    lastX: draggable.state.x,
                    lastY: draggable.state.y
                };
            }

            // A lot faster than stringify/parse
            function cloneBounds(bounds /*: Bounds*/) /*: Bounds*/ {
                return {
                    left: bounds.left,
                    top: bounds.top,
                    right: bounds.right,
                    bottom: bounds.bottom
                };
            }

            /***/ },
        /* 9 */
        /***/ function(module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function(process) {'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });

                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

                var _react = __webpack_require__(2);

                var _react2 = _interopRequireDefault(_react);

                var _reactDom = __webpack_require__(3);

                var _reactDom2 = _interopRequireDefault(_reactDom);

                var _domFns = __webpack_require__(5);

                var _positionFns = __webpack_require__(8);

                var _shims = __webpack_require__(6);

                var _log = __webpack_require__(11);

                var _log2 = _interopRequireDefault(_log);

                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

                // Simple abstraction for dragging events names.
                /*:: import type {EventHandler} from './utils/types';*/
                var eventsFor = {
                    touch: {
                        start: 'touchstart',
                        move: 'touchmove',
                        stop: 'touchend'
                    },
                    mouse: {
                        start: 'mousedown',
                        move: 'mousemove',
                        stop: 'mouseup'
                    }
                };

                // Default to mouse events.
                var dragEventFor = eventsFor.mouse;

                //
                // Define <DraggableCore>.
                //
                // <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
                // work well with libraries that require more control over the element.
                //

                /*:: type CoreState = {
                 dragging: boolean,
                 lastX: number,
                 lastY: number,
                 touchIdentifier: ?number
                 };*/

                var DraggableCore = function (_React$Component) {
                    _inherits(DraggableCore, _React$Component);

                    function DraggableCore() {
                        var _ref;

                        var _temp, _this, _ret;

                        _classCallCheck(this, DraggableCore);

                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }

                        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DraggableCore.__proto__ || Object.getPrototypeOf(DraggableCore)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
                            dragging: false,
                            // Used while dragging to determine deltas.
                            lastX: NaN, lastY: NaN,
                            touchIdentifier: null
                        }, _this.handleDragStart = function (e) {
                            // Make it possible to attach event handlers on top of this one.
                            _this.props.onMouseDown(e);

                            // Only accept left-clicks.
                            if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;

                            // Get nodes. Be sure to grab relative document (could be iframed)
                            var domNode = _reactDom2.default.findDOMNode(_this);
                            var ownerDocument = domNode.ownerDocument;

                            // Short circuit if handle or cancel prop was provided and selector doesn't match.

                            if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, domNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, domNode)) {
                                return;
                            }

                            // Set touch identifier in component state if this is a touch event. This allows us to
                            // distinguish between individual touches on multitouch screens by identifying which
                            // touchpoint was set to this element.
                            var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
                            _this.setState({ touchIdentifier: touchIdentifier });

                            // Get the current drag point from the event. This is used as the offset.
                            var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _this);
                            if (position == null) return; // not possible but satisfies flow
                            var x = position.x,
                                y = position.y;

                            // Create an event object with all the data parents need to make a decision here.

                            var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);

                            (0, _log2.default)('DraggableCore: handleDragStart: %j', coreEvent);

                            // Call event handler. If it returns explicit false, cancel.
                            (0, _log2.default)('calling', _this.props.onStart);
                            var shouldUpdate = _this.props.onStart(e, coreEvent);
                            if (shouldUpdate === false) return;

                            // Add a style to the body to disable user-select. This prevents text from
                            // being selected all over the page.
                            if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument.body);

                            // Initiate dragging. Set the current x and y as offsets
                            // so we know how much we've moved during the drag. This allows us
                            // to drag elements around even if they have been moved, without issue.
                            _this.setState({
                                dragging: true,

                                lastX: x,
                                lastY: y
                            });

                            // Add events to the document directly so we catch when the user's mouse/touch moves outside of
                            // this element. We use different events depending on whether or not we have detected that this
                            // is a touch-capable device.
                            (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
                            (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
                        }, _this.handleDrag = function (e) {

                            // Prevent scrolling on mobile devices, like ipad/iphone.
                            if (e.type === 'touchmove') e.preventDefault();

                            // Get the current drag point from the event. This is used as the offset.
                            var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
                            if (position == null) return;
                            var x = position.x,
                                y = position.y;

                            // Snap to grid if prop has been provided

                            if (x !== x) debugger;

                            if (Array.isArray(_this.props.grid)) {
                                var deltaX = x - _this.state.lastX,
                                    deltaY = y - _this.state.lastY;

                                var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);

                                var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);

                                deltaX = _snapToGrid2[0];
                                deltaY = _snapToGrid2[1];

                                if (!deltaX && !deltaY) return; // skip useless drag
                                x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;
                            }

                            var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);

                            (0, _log2.default)('DraggableCore: handleDrag: %j', coreEvent);

                            // Call event handler. If it returns explicit false, trigger end.
                            var shouldUpdate = _this.props.onDrag(e, coreEvent);
                            if (shouldUpdate === false) {
                                try {
                                    // $FlowIgnore
                                    _this.handleDragStop(new MouseEvent('mouseup'));
                                } catch (err) {
                                    // Old browsers
                                    var event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);
                                    // I see why this insanity was deprecated
                                    // $FlowIgnore
                                    event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                                    _this.handleDragStop(event);
                                }
                                return;
                            }

                            _this.setState({
                                lastX: x,
                                lastY: y
                            });
                        }, _this.handleDragStop = function (e) {
                            if (!_this.state.dragging) return;

                            var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
                            if (position == null) return;
                            var x = position.x,
                                y = position.y;

                            var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);

                            var _ReactDOM$findDOMNode = _reactDom2.default.findDOMNode(_this),
                                ownerDocument = _ReactDOM$findDOMNode.ownerDocument;

                            // Remove user-select hack


                            if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);

                            (0, _log2.default)('DraggableCore: handleDragStop: %j', coreEvent);

                            // Reset the el.
                            _this.setState({
                                dragging: false,
                                lastX: NaN,
                                lastY: NaN
                            });

                            // Call event handler
                            _this.props.onStop(e, coreEvent);

                            // Remove event handlers
                            (0, _log2.default)('DraggableCore: Removing handlers');
                            (0, _domFns.removeEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
                            (0, _domFns.removeEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
                        }, _this.onMouseDown = function (e) {
                            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse

                            return _this.handleDragStart(e);
                        }, _this.onMouseUp = function (e) {
                            dragEventFor = eventsFor.mouse;

                            return _this.handleDragStop(e);
                        }, _this.onTouchStart = function (e) {
                            // We're on a touch device now, so change the event handlers
                            dragEventFor = eventsFor.touch;

                            return _this.handleDragStart(e);
                        }, _this.onTouchEnd = function (e) {
                            // We're on a touch device now, so change the event handlers
                            dragEventFor = eventsFor.touch;

                            return _this.handleDragStop(e);
                        }, _temp), _possibleConstructorReturn(_this, _ret);
                    }

                    _createClass(DraggableCore, [{
                        key: 'componentWillUnmount',
                        value: function componentWillUnmount() {
                            // Remove any leftover event handlers. Remove both touch and mouse handlers in case
                            // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
                            var _ReactDOM$findDOMNode2 = _reactDom2.default.findDOMNode(this),
                                ownerDocument = _ReactDOM$findDOMNode2.ownerDocument;

                            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
                            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
                            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
                            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
                            if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);
                        }

                        // Same as onMouseDown (start drag), but now consider this a touch device.

                    }, {
                        key: 'render',
                        value: function render() /*: React.Element<any>*/ {
                            // Reuse the child provided
                            // This makes it flexible to use whatever element is wanted (div, ul, etc)
                            return _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
                                style: (0, _domFns.styleHacks)(this.props.children.props.style),

                                // Note: mouseMove handler is attached to document so it will still function
                                // when the user drags quickly and leaves the bounds of the element.
                                onMouseDown: this.onMouseDown,
                                onTouchStart: this.onTouchStart,
                                onMouseUp: this.onMouseUp,
                                onTouchEnd: this.onTouchEnd
                            });
                        }
                    }]);

                    return DraggableCore;
                }(_react2.default.Component);

                DraggableCore.displayName = 'DraggableCore';
                DraggableCore.propTypes = {
                    /**
                     * `allowAnyClick` allows dragging using any mouse button.
                     * By default, we only accept the left button.
                     *
                     * Defaults to `false`.
                     */
                    allowAnyClick: _react.PropTypes.bool,

                    /**
                     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
                     * with the exception of `onMouseDown`, will not fire.
                     */
                    disabled: _react.PropTypes.bool,

                    /**
                     * By default, we add 'user-select:none' attributes to the document body
                     * to prevent ugly text selection during drag. If this is causing problems
                     * for your app, set this to `false`.
                     */
                    enableUserSelectHack: _react.PropTypes.bool,

                    /**
                     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
                     * instead of using the parent node.
                     */
                    offsetParent: function offsetParent(props, propName) {
                        if (process.browser && props[propName] && props[propName].nodeType !== 1) {
                            throw new Error('Draggable\'s offsetParent must be a DOM Node.');
                        }
                    },

                    /**
                     * `grid` specifies the x and y that dragging should snap to.
                     */
                    grid: _react.PropTypes.arrayOf(_react.PropTypes.number),

                    /**
                     * `handle` specifies a selector to be used as the handle that initiates drag.
                     *
                     * Example:
                     *
                     * ```jsx
                     *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable handle=".handle">
	   *              <div>
	   *                  <div className="handle">Click me to drag</div>
	   *                  <div>This is some other content</div>
	   *              </div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
                     * ```
                     */
                    handle: _react.PropTypes.string,

                    /**
                     * `cancel` specifies a selector to be used to prevent drag initialization.
                     *
                     * Example:
                     *
                     * ```jsx
                     *   let App = React.createClass({
	   *       render: function () {
	   *           return(
	   *               <Draggable cancel=".cancel">
	   *                   <div>
	   *                     <div className="cancel">You can't drag from here</div>
	   *                     <div>Dragging here works fine</div>
	   *                   </div>
	   *               </Draggable>
	   *           );
	   *       }
	   *   });
                     * ```
                     */
                    cancel: _react.PropTypes.string,

                    /**
                     * Called when dragging starts.
                     * If this function returns the boolean false, dragging will be canceled.
                     */
                    onStart: _react.PropTypes.func,

                    /**
                     * Called while dragging.
                     * If this function returns the boolean false, dragging will be canceled.
                     */
                    onDrag: _react.PropTypes.func,

                    /**
                     * Called when dragging stops.
                     * If this function returns the boolean false, the drag will remain active.
                     */
                    onStop: _react.PropTypes.func,

                    /**
                     * A workaround option which can be passed if onMouseDown needs to be accessed,
                     * since it'll always be blocked (as there is internal use of onMouseDown)
                     */
                    onMouseDown: _react.PropTypes.func,

                    /**
                     * These properties should be defined on the child, not here.
                     */
                    className: _shims.dontSetMe,
                    style: _shims.dontSetMe,
                    transform: _shims.dontSetMe
                };
                DraggableCore.defaultProps = {
                    allowAnyClick: false, // by default only accept left click
                    cancel: null,
                    disabled: false,
                    enableUserSelectHack: true,
                    offsetParent: null,
                    handle: null,
                    grid: null,
                    transform: null,
                    onStart: function onStart() {},
                    onDrag: function onDrag() {},
                    onStop: function onStop() {},
                    onMouseDown: function onMouseDown() {}
                };
                exports.default = DraggableCore;
                /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

            /***/ },
        /* 10 */
        /***/ function(module, exports) {

            // shim for using process in browser
            var process = module.exports = {};

            // cached from whatever global is present so that test runners that stub it
            // don't break things.  But we need to wrap it in a try catch in case it is
            // wrapped in strict mode code which doesn't define any globals.  It's inside a
            // function because try/catches deoptimize in certain engines.

            var cachedSetTimeout;
            var cachedClearTimeout;

            function defaultSetTimout() {
                throw new Error('setTimeout has not been defined');
            }
            function defaultClearTimeout () {
                throw new Error('clearTimeout has not been defined');
            }
            (function () {
                try {
                    if (typeof setTimeout === 'function') {
                        cachedSetTimeout = setTimeout;
                    } else {
                        cachedSetTimeout = defaultSetTimout;
                    }
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === 'function') {
                        cachedClearTimeout = clearTimeout;
                    } else {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } ())
            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout(fun, 0);
                } catch(e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch(e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }


            }
            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout(marker);
                } catch (e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout.call(null, marker);
                    } catch (e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout.call(this, marker);
                    }
                }



            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                    return;
                }
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }

            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;

                var len = queue.length;
                while(len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }

            process.nextTick = function (fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                }
            };

            // v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = ''; // empty string to avoid regexp issues
            process.versions = {};

            function noop() {}

            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;

            process.binding = function (name) {
                throw new Error('process.binding is not supported');
            };

            process.cwd = function () { return '/' };
            process.chdir = function (dir) {
                throw new Error('process.chdir is not supported');
            };
            process.umask = function() { return 0; };


            /***/ },
        /* 11 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = log;

            /*eslint no-console:0*/
            function log() {
                var _console;

                if ((undefined)) (_console = console).log.apply(_console, arguments);
            }

            /***/ }
        /******/ ])
});
;